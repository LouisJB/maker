/* 
 * Taken from SBT code
 * Copyright 2008, 2009  Mark Harrah
 */
package plugin

import java.io.File
import maker.utils.Log
import maker.utils.FileUtils._
import java.io.BufferedWriter


case class SourceFileAssociation(parent : File, child : File)

object PersistedFileAssociation{
  def apply(persistFile : File) : PersistedFileAssociation = {
    var list : List[SourceFileAssociation] = withFileLineReader(persistFile){
      line ⇒ 
        val List(source, assoc) = line.split(":").toList.map(file)
        SourceFileAssociation(source, assoc)
    }
    PersistedFileAssociation(Some(persistFile), list.toSet)
  }
  def apply(set : Set[SourceFileAssociation]) : PersistedFileAssociation = PersistedFileAssociation(None, set)
}

case class PersistedFileAssociation(
  persistFile : Option[File] = None, 
  var set : Set[SourceFileAssociation] = Set[SourceFileAssociation]()
){

  def persist{
    persistFile match {
      case Some(f) ⇒ 
        withFileWriter(f) {
          writer : BufferedWriter =>
            set.foreach {
              case SourceFileAssociation(source, assoc) ⇒ 
                writer.println(source.getAbsolutePath + ":" + assoc.getAbsolutePath)
            }
        }
      case None ⇒ throw new Exception("No file to persist to")
    }
  }

  def += (source : File, assoc : File){
    // The files that come from the compiler plugin have a mixture of 
    // relative and absolute paths.
    set = set + SourceFileAssociation(source.asAbsoluteFile, assoc.asAbsoluteFile)
  }

  def removeParent(source : File){
    val absSource = source.asAbsoluteFile
    set = set.filterNot(_.parent == absSource)
  }
  def removeChild(source : File){
    val absSource = source.asAbsoluteFile
    set = set.filterNot(_.child == absSource)
  }
  def parents(sources : Set[File]) = {
    val absSources = sources.map(_.asAbsoluteFile)
    set.filter{
      case SourceFileAssociation(_, child) ⇒ absSources.contains(child)
    }.map(_.parent)
  }
  def children(sources : Set[File]) = {
    val absSources = sources.map(_.asAbsoluteFile)
    set.filter{
      case SourceFileAssociation(parent, _) ⇒ absSources.contains(parent)
    }.map(_.child)
  }

  def sourceFiles = set.map(_.parent)

  override def toString = {
    set.map{case SourceFileAssociation(source, file) ⇒ source + " → " + file}.mkString("\n\t", "\n\t", "\n")
  }
}

object ProjectFileDependencies{
  def apply(makerDirectory : File) : ProjectFileDependencies = {
    ProjectFileDependencies(
      PersistedFileAssociation(Some(file(makerDirectory, "source_dependencies"))),
      PersistedFileAssociation(Some(file(makerDirectory, "binary_dependencies"))),
      PersistedFileAssociation(Some(file(makerDirectory, "generated_classes")))
    )
  }
}


case class ProjectFileDependencies(
  var sourceDependencies : PersistedFileAssociation,
  var binaryDependencies : PersistedFileAssociation,
  var generatedClasses : PersistedFileAssociation
) {
  
  private val dependencies = List(sourceDependencies, binaryDependencies, generatedClasses)
	/** Called before the source at the given location is processed. */
	def beginSource(source : File){
	  sourceDependencies.removeChild(source)
    binaryDependencies.removeParent(source)
    generatedClasses.removeParent(source)
    //dependencies.foreach(_.removeSource(source))
  }

	/** Called to indicate that the source file <code>source</code> depends on the source file
	*   `<code>dependsOn</code>.  Note that only source files included in the current compilation will
	* passed to this method.  Dependencies on classes generated by sources not in the current compilation will
	* be passed as class dependencies to the classDependency method.*/
	def sourceDependency(parent : File, child : File){
    //Log.info("Adding source dep " + parent + ", " + child)
	  sourceDependencies += (parent, child)
  }

	/** Called to indicate that the source file <code>source</code> depends on the top-level
	* class named <code>name</code> from class or jar file <code>binary</code>. */
	def binaryDependency(source : File, classOrJar : File, className : String){
    //Log.info("Adding binary dep " + source + ", " + classOrJar + ", " + className)
	  binaryDependencies += (source, classOrJar)
  }

	/** Called to indicate that the source file <code>source</code> produces a class file at
	* <code>module</code> contain class <code>name</code>.*/
	def generatedClass(source : File, classFile : File, className : String){
    Log.debug("Adding generated class " + source + ", " + classFile + ", " + className)
	  generatedClasses += (source, classFile)
    assert(sourceFiles.size > 0, "Source files must be non empty")
  }

	/** Called after the source at the given location has been processed. */
	def endSource(source : File){}

	def sourceChildDependencies(sources : Set[File]) = {
	  val sourceFiles = sourceDependencies.children(sources)
	  val classFiles = generatedClasses.children(sources)
	  val moreSourceFiles = binaryDependencies.parents(classFiles)
    sourceFiles ++ moreSourceFiles
  }

  def sourceParentDependencies(sources : Set[File]) = {
    val sourceFiles = sourceDependencies.parents(sources)
    val classFiles = binaryDependencies.children(sources).filter(_.getPath.endsWith("class"))
    val klass = classFiles.head
    
    val moreSourceFiles = generatedClasses.parents(classFiles)
    sources ++ moreSourceFiles
  }

  def sourceFiles : Set[File] = dependencies.flatMap(_.sourceFiles).toSet

  def classFilesGeneratedBy(sources : Set[File]) = generatedClasses.children(sources).toSet

  def persist{
    dependencies.foreach(_.persist)
  }
}
