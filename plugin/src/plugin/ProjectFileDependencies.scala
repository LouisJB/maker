/* 
 * Taken from SBT code
 * Copyright 2008, 2009  Mark Harrah
 */
package plugin

import java.io.File
import maker.utils.Log
import maker.utils.FileUtils._
import java.io.BufferedWriter


case class SourceFileAssociation(source : File, assoc : File)

object PersistedFileAssociation{
  def apply(persistFile : File) : PersistedFileAssociation = {
    var list : List[SourceFileAssociation] = withFileLineReader(persistFile){
      line ⇒ 
        val List(source, assoc) = line.split(":").toList.map(file)
        SourceFileAssociation(source, assoc)
    }
    PersistedFileAssociation(Some(persistFile), list)
  }
  def apply(list : List[SourceFileAssociation]) : PersistedFileAssociation = PersistedFileAssociation(None, list)
}

case class PersistedFileAssociation(
  persistFile : Option[File] = None, 
  private var list : List[SourceFileAssociation] = Nil
){

  def persist{
    persistFile match {
      case Some(f) ⇒ 
        withFileWriter(f) {
          writer : BufferedWriter =>
            list.foreach {
              case SourceFileAssociation(source, assoc) ⇒ 
                writer.println(source.getPath + ":" + assoc.getPath)
            }
        }
      case None ⇒ throw new Exception("No file to persist to")
    }
  }

  def += (source : File, assoc : File){
    list = SourceFileAssociation(source, assoc) :: list
  }

  def removeSource(source : File){
    list = list.filterNot(_.source == source)
  }
  def filesAssociatedWith(sources : Set[File]) = {
    list.filter{assoc ⇒ sources.contains(assoc.source)}.map(_.assoc).toSet
  }
  def sourceFilesAccociatedWith(assocs : Set[File]) : Set[File] = {
    list.filter{assoc ⇒ assocs.contains(assoc.assoc)}.map(_.source).toSet
  }

  def sourceFiles = list.map(_.source).toSet

  override def toString = {
    list.map{case SourceFileAssociation(source, file) ⇒ source + " → " + file}.mkString("\n\t", "\n\t", "\n")
  }
}

object ProjectFileDependencies{
  def apply(makerDirectory : File) : ProjectFileDependencies = {
    ProjectFileDependencies(
      PersistedFileAssociation(Some(file(makerDirectory, "source_dependencies"))),
      PersistedFileAssociation(Some(file(makerDirectory, "binary_dependencies"))),
      PersistedFileAssociation(Some(file(makerDirectory, "generated_classes")))
    )
  }
}


case class ProjectFileDependencies(
  var sourceDependencies : PersistedFileAssociation,
  var binaryDependencies : PersistedFileAssociation,
  var generatedClasses : PersistedFileAssociation
) {
  
  private val dependencies = List(sourceDependencies, binaryDependencies, generatedClasses)
	/** Called before the source at the given location is processed. */
	def beginSource(source : File){
	  dependencies.foreach(_.removeSource(source))
  }

	/** Called to indicate that the source file <code>source</code> depends on the source file
	* <code>dependsOn</code>.  Note that only source files included in the current compilation will
	* passed to this method.  Dependencies on classes generated by sources not in the current compilation will
	* be passed as class dependencies to the classDependency method.*/
	def sourceDependency(dependsOn : File, source : File){
    //Log.info("Adding source dep " + source + ", " + dependsOn)
	  sourceDependencies += (source, dependsOn)
  }

	/** Called to indicate that the source file <code>source</code> depends on the top-level
	* class named <code>name</code> from class or jar file <code>binary</code>. */
	def binaryDependency(source : File, classOrJar : File, className : String){
    //Log.info("Adding binary dep " + source + ", " + classOrJar + ", " + className)
	  binaryDependencies += (source, classOrJar)
  }

	/** Called to indicate that the source file <code>source</code> produces a class file at
	* <code>module</code> contain class <code>name</code>.*/
	def generatedClass(source : File, classFile : File, className : String){
    Log.info("Adding generated class " + source + ", " + classFile + ", " + className)
	  generatedClasses += (source, classFile)
  }

	/** Called after the source at the given location has been processed. */
	def endSource(source : File){}

	def sourceFilesThatDependOn(sources : Set[File]) = {
	  val sourceFiles = sourceDependencies.filesAssociatedWith(sources)
	  val classFiles  = binaryDependencies.filesAssociatedWith(sources)
	  val moreSourceFiles : Set[File] = generatedClasses.sourceFilesAccociatedWith(classFiles)
    sourceFiles ++ moreSourceFiles
  }

  def sourceFiles : Set[File] = dependencies.flatMap(_.sourceFiles).toSet

  def classFilesGeneratedBy(sources : Set[File]) = generatedClasses.filesAssociatedWith(sources).toSet

  def persist{
    dependencies.foreach(_.persist)
  }
}
