/* 
 * Taken from SBT code
 * Copyright 2008, 2009  Mark Harrah
 */
package plugin

import java.io.File
import maker.utils.Log
import maker.utils.FileUtils._
import java.io.BufferedWriter

trait AnalysisCallback
{
	/** Called before the source at the given location is processed. */
	def beginSource(source : File)
	/** Called to indicate that the source file <code>source</code> depends on the source file
	* <code>dependsOn</code>.  Note that only source files included in the current compilation will
	* passed to this method.  Dependencies on classes generated by sources not in the current compilation will
	* be passed as class dependencies to the classDependency method.*/
	def sourceDependency(dependsOn : File, source : File)
	/** Called to indicate that the source file <code>source</code> depends on the top-level
	* class named <code>name</code> from class or jar file <code>binary</code>. */
	def binaryDependency(source : File, binary : File, name : String)
	/** Called to indicate that the source file <code>source</code> produces a class file at
	* <code>module</code> contain class <code>name</code>.*/
	def generatedClass(source : File, module : File, name : String)
	/** Called after the source at the given location has been processed. */
	def endSource(sourcePath : File)
	/** Called when the public API of a source file is extracted. */
//def api(sourceFile : File, source : xsbti.api.SourceAPI)
}


case class SourceFileAssociation(source : File, assoc : File)
object PersistedFileAssociation{
  def apply(persistFile : File) : PersistedFileAssociation = {
    var list : List[SourceFileAssociation] = withFileLineReader(persistFile){
      line ⇒ 
        val List(source, assoc) = line.split(":").toList.map(file)
        SourceFileAssociation(source, assoc)
    }
    PersistedFileAssociation(Some(persistFile), list)
  }
  def apply(list : List[SourceFileAssociation]) : PersistedFileAssociation = PersistedFileAssociation(None, list)
}
case class PersistedFileAssociation(persistFile : Option[File], private var list : List[SourceFileAssociation]){

  def persist{
    persistFile match {
      case Some(f) ⇒ 
        withFileWriter(f) {
          writer : BufferedWriter =>
            list.foreach {
              case SourceFileAssociation(source, assoc) ⇒ 
                writer.println(source.getPath + ":" + assoc.getPath)
            }
        }
      case None ⇒ throw new Exception("No file to persist to")
    }
  }

  def += (source : File, assoc : File){
    list = SourceFileAssociation(source, assoc) :: list
  }

  def removeSource(source : File){
    list = list.filterNot(_.source == source)
  }
  def filesAssociatedWith(source : File) = {
    list.filter(_.source == source).map(_.assoc)
  }
  def sourceFilesAccociatedWith(assoc : File) = {
    list.filter(_.assoc == assoc).map(_.source)
  }
}

case class AnalysisCallbackImpl(
  private var sourceDependencies : PersistedFileAssociation,
  private var binaryDependencies : PersistedFileAssociation,
  private var generatedClasses : PersistedFileAssociation

) 
  extends AnalysisCallback
{
  
	def beginSource(source : File){
	  List(sourceDependencies, binaryDependencies, generatedClasses).foreach(_.removeSource(source))
  }

	def sourceDependency(dependsOn : File, source : File){
    //Log.info("Adding source dep " + source + ", " + dependsOn)
	  sourceDependencies += (source, dependsOn)
  }
	def binaryDependency(source : File, classOrJar : File, className : String){
    //Log.info("Adding binary dep " + source + ", " + classOrJar + ", " + className)
	  binaryDependencies += (source, classOrJar)
  }
	def generatedClass(source : File, classFile : File, className : String){
    //Log.info("Adding generated class " + source + ", " + classFile + ", " + className)
	  generatedClasses += (source, classFile)
  }
	def endSource(source : File){}

	def filesThatDependOn(source : File) = {
	  val sourceFiles = sourceDependencies.filesAssociatedWith(source)
	  val classFiles = binaryDependencies.filesAssociatedWith(source)
	  val moreSourceFiles = classFiles.flatMap{
      classFile ⇒ generatedClasses.sourceFilesAccociatedWith(classFile)
    }
    sourceFiles ::: moreSourceFiles
  }
}
